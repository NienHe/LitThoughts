# Overview

### API

使用 fetch 向後端送API

```javascript
const response = await fetch(`${apiBaseUrl}/api/v1/myposts`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        // 'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify({
        name: username,
        postOffset: currentPostOffset
      }),
      credentials: 'include'
    });
```

1.	javascript函數 fetch用於網路請求，返回Promise並使用await等待請求完成。
	apiBaseUel全域變數此處定義URL
2.	method指定http請求方法，這邊指定使用POST
3.	headers設置了Content-Type為application/json，表示請求的是JSON格式  
	身分驗證Authorization 發送token被注釋掉了，後面會解釋原因。
4.	body裡面包含了JSON格式訊息
5.	credentials是否在請求中發送cookies。  


### 補充說明 token 發送

先從後端程式碼來看，token是如何被打包到cookie裡面的。  
前端登入成功時，後端會生成一個token，並且帶有安全性設置，返回給前端儲存在cookie中。

```java
ResponseCookie cookie = ResponseCookie.from("token", token)
        .httpOnly(true)
        .secure(true)
        .domain("www.litthoughts.com")
        .path("/xxx")
        .maxAge(7 * 24 * 60 * 60)
        .sameSite("Strict")
        .build();

return ResponseEntity.ok()
        .header(HttpHeaders.SET_COOKIE, cookie.toString())
        .body(result);

```

1.	httpOnly:使得客戶端javaScript無法訪問這個cookie，減少XSS攻擊風險
2.	secure:代表著cookie只會在HTTPS上發送，確保資料傳輸安全。
3.	sameSite: "strict"防止CSRF攻擊，這個設置確保只有相同同源才會攜帶cookie`.
	簡單來說就是網站Domain, Path, Cookie一致，就會視為同源。
4.	domain, path:確保cookie只在指定的網域路徑中有效
5.	maxAge:設置cookie有效日期

這個就是我們前端拿到的cookie，裡面有包含JWT加密token。  
可以看到，前端通過這種方式發送cookie的優點包含防止XSS和CSRF攻擊，確保身分驗證token的安全性，有效防止潛在的安全威脅。